<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java-基础篇（4）数据类型</title>
      <link href="/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%884%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%884%EF%BC%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>在本章中，主要介绍一下 Java 最常用、也是基础考点的数据类型；我们都知道 Java 语言提供了八种基本类型：六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。并且还提供了其对应的引用类型。</p><hr><h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><table><thead><tr><th>类型</th><th>字节数/位数</th><th>最小值</th><th>最大值</th></tr></thead><tbody><tr><td><strong>byte</strong></td><td>1/8</td><td>-128（-2^7）</td><td>127（2^7-1）</td></tr><tr><td><strong>short</strong></td><td>2/16</td><td>-32768（-2^15）</td><td>32767（2^15 - 1）</td></tr><tr><td><strong>int</strong></td><td>4/32</td><td>-2,147,483,648（-2^31）</td><td>2,147,483,647（2^31 - 1）</td></tr><tr><td><strong>long</strong></td><td>8/64</td><td>-2^63</td><td>2^63 -1</td></tr><tr><td><strong>float</strong></td><td>4/32</td><td></td><td></td></tr><tr><td><strong>double</strong></td><td>8/64</td><td></td><td></td></tr></tbody></table><p><strong>char</strong>：在 Java 中是用 unicode来表示字符，所以 2 个字节来表示一个字符； 一个数字或英文或汉字都是一个字符，只不过数字和英文时，存储的2个字节的第一个字节都为0，就是浪费了点空间。存汉字就占满了2个字节。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">char</span> c1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> c2 <span class="token operator">=</span> <span class="token string">'中'</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"char字符："</span><span class="token operator">+</span> c1 <span class="token operator">+</span> <span class="token string">",字节数："</span> <span class="token operator">+</span> <span class="token function">charToByte</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"char字符："</span><span class="token operator">+</span> c2 <span class="token operator">+</span> <span class="token string">",字节数："</span> <span class="token operator">+</span> <span class="token function">charToByte</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">charToByte</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">0xFF00</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    b<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span><span class="token punctuation">(</span>c <span class="token operator">&amp;</span> <span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><pre><code>char字符：a,字节数：2char字符：中,字节数：2</code></pre><p><strong>boolean</strong>：在 Java 基本类型中只有两个状态，true、false，理论上只占一个字节，但是实际如下：</p><ul><li>单个的boolean类型变量在编译的时候是使用的 int 类型，即 boolean a = true 时，这个a在 JVM 中<strong>占用 4 个字节</strong>，即32位；</li><li>boolean类型的数组时，在编译时是作为byte array来编译的。所以，boolean数组里的每一个元件占用一个字节；即 boolean[] b = new boolean[10] 的数组时，每一个boolean在 JVM中占<strong>一个字节</strong>；</li></ul><p><strong>注意</strong>： <code>float</code> 和 <code>double</code> 都不能表示精确的值，所以一般不能用在计算货币，要想精度不失效，可以使用 <code>BigDecimal</code></p><hr><h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><p>在 Java 中引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</p><ul><li>对象、数组都是引用数据类型；</li><li>所有引用类型的默认值都是null；</li><li>一个引用变量可以用来引用任何与之兼容的类型</li></ul><p>我们的基本类型都有对应的引用类型，且基本类型与其对应的引用类型之间的赋值使用自动装箱与拆箱完成</p><p><strong>Integer需要几个字节 ？</strong>，答案是每个Integer 占用了 3 * 4bytes</p><ul><li><p>Integer在内存中有一个指向方法区里边类信息的指针，这个指针占用4bytes；</p></li><li><p>另外Integer中实例变量只有一个int类型的字段，所以为32位，4bytes。</p></li><li><p>有4bytes的指向对象池的指针</p></li></ul><hr><h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a><strong>自动装箱和拆箱</strong></h2><p>自动拆箱：故名思议就是<code>将对象重新转化为基本数据类型</code>；是享元模式（flyweight）</p><pre class=" language-java"><code class="language-java">Integer num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//装箱</span><span class="token keyword">int</span> num1 <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//拆箱</span></code></pre><p><strong>基本数据类型和引用数据类型区别</strong></p><ul><li><code>基本数据类型</code>在被创建时，数值直接存储在栈上。</li><li><code>引用数据类型</code>在被创建时，对象的具体信息都存储在堆内存上，对象的引用地址存储在栈上</li></ul><hr><h2 id="new-Integer-123-与-Integer-valueOf-123-区别"><a href="#new-Integer-123-与-Integer-valueOf-123-区别" class="headerlink" title="new Integer(123) 与 Integer.valueOf(123)区别"></a>new Integer(123) 与 Integer.valueOf(123)区别</h2><p>注意：我们使用基本类型的引用类型新建对象时，可能出现一些意料之外的变化，如：</p><pre class=" language-java"><code class="language-java">Integer x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>Integer y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x <span class="token operator">==</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// false</span>Integer z <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>Integer k <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>z <span class="token operator">==</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// true</span></code></pre><p>为什么出现以上结果，这是因为 valueOf() 方法的实现，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容，而不是每次新建一个对象，所以：</p><ul><li>new Integer(10) 每次都会新建一个对象；</li><li>Integer.valueOf(10) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><p><strong>注意：4种整型都有相同效果，有兴趣的可以分别试试 Byte、Short、Integer、Long 的效果</strong></p><hr><h2 id="Integer或-Short-缓存池上下边界"><a href="#Integer或-Short-缓存池上下边界" class="headerlink" title="Integer或 Short  缓存池上下边界"></a>Integer或 Short  缓存池上下边界</h2><p>Short 其实和 Integer 是相同效果，这里以 Integer 为例</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在-128~127 之外的数</span>Integer num1 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>   Integer num2 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num1==num2: "</span><span class="token operator">+</span><span class="token punctuation">(</span>num1<span class="token operator">==</span>num2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//false               </span><span class="token comment" spellcheck="true">// 在-128~127 之内的数 </span>Integer num3 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>   Integer num4 <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"num3==num4: "</span><span class="token operator">+</span><span class="token punctuation">(</span>num3<span class="token operator">==</span>num4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//true   </span></code></pre><p>为什么出现以上结果，这是因为 *<em>Integer *</em>如果超过了从–128到127之间的值，被装箱后的Integer对象并不会被重用，即相当于每次装箱时都新建一个 Integer对象</p><hr><h2 id="IntegerCache-源码分析"><a href="#IntegerCache-源码分析" class="headerlink" title="IntegerCache 源码分析"></a>IntegerCache 源码分析</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntegerCache</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Integer cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// high value may be configured by property</span>        <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>        String integerCacheHighPropValue <span class="token operator">=</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">"java.lang.Integer.IntegerCache.high"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// Maximum array size is Integer.MAX_VALUE</span>                h <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> NumberFormatException nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If the property cannot be parsed into an int, ignore it.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        high <span class="token operator">=</span> h<span class="token punctuation">;</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>            cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// range [-128, 127] must be interned (JLS7 5.1.7)</span>        <span class="token keyword">assert</span> IntegerCache<span class="token punctuation">.</span>high <span class="token operator">>=</span> <span class="token number">127</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">IntegerCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>  通过源码，可以知道默认的Integer缓存池的大小范围是 -128~127。也是是说在这个范围里面，只要缓存池中有需要的值，会直接从缓存池中来获取，而不是重新new一个对象。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span></code></pre><blockquote><p>  在 jdk 1.8 IntegerCache 缓冲池中，可以看出，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax= 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p></blockquote><hr><h1 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h1><h2 id="String-不可变"><a href="#String-不可变" class="headerlink" title="String 不可变"></a>String 不可变</h2><p>String 类型 是一个final修饰的类型。因此它不可被继承。在 Java 8 中，String 内部使用 char 数组存储数据。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> Comparable<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> CharSequence <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，<strong>因此可以保证 String 不可变。</strong></p><p><strong>String 不可变的好处</strong></p><ul><li><strong>可以缓存 hash 值</strong>：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li><li><strong>String Pool 的需要</strong>：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。<strong>只有 String 是不可变的，才可能使用 String Pool</strong>。</li><li><strong>安全性</strong>：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。String 经常作为参数，String 不可变性可以保证参数不可变。</li></ul><h2 id="String-赋值"><a href="#String-赋值" class="headerlink" title="String 赋值"></a>String 赋值</h2><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token string">"bbb"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s5 <span class="token operator">==</span> s6<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span></code></pre><p>如果是采用 “bbb” 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。而不是象new一样放在压缩堆中；当声明这样的一个字符串后，JVM会在常量池中先查找有没有一个值为”bbb”的对象，</p><ul><li>如果有：就会把它赋给当前引用。即原来那个引用和现在这个引用指点向了同一对象,</li><li>如果没有：则在常量池中新创建一个”bbb”,</li></ul><p>下一次如果有String s2 = “bbb”；又会将s2指向”abcd”这个对象；即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象.</p><p>而<code>String s = new String(&quot;abcd&quot;);</code>和其它任何对象一样，每调用一次就产生一个对象</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//代码1  </span>String sa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span>                                          String sb <span class="token operator">=</span> <span class="token string">"cd"</span><span class="token punctuation">;</span>                                       String sab<span class="token operator">=</span>sa<span class="token operator">+</span>sb<span class="token punctuation">;</span>                                      String s<span class="token operator">=</span><span class="token string">"abcd"</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sab<span class="token operator">==</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false  </span><span class="token comment" spellcheck="true">//当执行sa+sb时，JVM首先会在堆中创建一个StringBuilder类，将刚生成的String对象的堆地址存放在局部变量sab中</span><span class="token comment" spellcheck="true">//局部变量 s 存储的是常量池中"abcd"所对应的拘留字符串对象的地址</span><span class="token comment" spellcheck="true">//代码2  </span>String sc<span class="token operator">=</span><span class="token string">"ab"</span><span class="token operator">+</span><span class="token string">"cd"</span><span class="token punctuation">;</span>  String sd<span class="token operator">=</span><span class="token string">"abcd"</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sc<span class="token operator">==</span>sd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true  </span><span class="token comment" spellcheck="true">//"ab"+"cd"会直接在编译期就合并成常量"abcd"， 因此相同字面值常量"abcd"所对应的是同一个拘留字符串对象，自然地址也就相同。</span></code></pre><p>扩展：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span></code></pre><p>这种方式一共会创建两个字符串对象（<strong>前提是 String Pool 中还没有 “abc” 字符串对象</strong>）。</p><ul><li>“abc” 属于字符串字面量，因此编译时期会在 <strong>String Pool 中</strong>创建一个字符串对象，指向这个字符串字面量；</li><li>而使用 new 的方式会在<strong>堆中</strong>创建一个字符串对象。</li></ul><h2 id="String-字节-编码"><a href="#String-字节-编码" class="headerlink" title="String 字节/编码"></a>String 字节/编码</h2><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16 编码中，中文字符和英文字符都占 2 个字节。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        String str1 <span class="token operator">=</span> <span class="token string">"a"</span><span class="token punctuation">;</span>        String str2 <span class="token operator">=</span> <span class="token string">"你"</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"utf-8:'a'所占的字节数:"</span> <span class="token operator">+</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"gbk:'a'所占的字节数:"</span> <span class="token operator">+</span> str1<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"gbk"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"utf-8:'中'所占的字节数:"</span> <span class="token operator">+</span> str2<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"gbk:'中'所占的字节数:"</span> <span class="token operator">+</span> str2<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token string">"gbk"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">UnsupportedEncodingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>运行结果如下：</p><pre class=" language-java"><code class="language-java">utf<span class="token operator">-</span><span class="token number">8</span><span class="token operator">:</span><span class="token string">'a'</span>所占的字节数<span class="token operator">:</span><span class="token number">1</span>gbk<span class="token operator">:</span><span class="token string">'a'</span>所占的字节数<span class="token operator">:</span><span class="token number">1</span>utf<span class="token operator">-</span><span class="token number">8</span><span class="token operator">:</span><span class="token string">'中'</span>所占的字节数<span class="token operator">:</span><span class="token number">3</span>gbk<span class="token operator">:</span><span class="token string">'中'</span>所占的字节数<span class="token operator">:</span><span class="token number">2</span></code></pre><h2 id="String、StringBuffer、-StringBuilder的区别"><a href="#String、StringBuffer、-StringBuilder的区别" class="headerlink" title="String、StringBuffer、 StringBuilder的区别"></a>String、StringBuffer、 StringBuilder的区别</h2><ul><li><p>从运行速度上说，StringBuilder&gt;StringBuffer&gt;String，因为String是不可变的对象</p></li><li><p>String：是字符串常量（由final修饰），StringBuffer和StringBuilder 是字符串变量</p></li><li><p><strong>StringBuffer：有同步锁</strong>，但效率低，适用于多线程下字符缓冲区进行大量操作。</p></li><li><p>StringBuilder：效率高，线程不安全，适用于单线程下的字符缓冲区进行大量操作的情况；</p><p>​    </p></li></ul><p><strong>StringBuffer 和 StringBuilder 能大量操作字符的原理</strong></p><p>在append是后，采用了<code>Arrays.copyOf（）</code> 进行了数组复制</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">append</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    toStringCache <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// AbstractStringBuilder 类</span><span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>str <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">appendNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>count <span class="token operator">+</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 采用复制方式增加数组长度</span>    str<span class="token punctuation">.</span><span class="token function">getChars</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> value<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    count <span class="token operator">+=</span> len<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimumCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minimumCapacity <span class="token operator">-</span> value<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span>                              <span class="token function">newCapacity</span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><hr><h2 id="String-Pool"><a href="#String-Pool" class="headerlink" title="String Pool"></a>String Pool</h2><ul><li>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定</li><li>String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中</li></ul><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// false</span>String s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String s4 <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s4<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// true</span></code></pre><p><strong>String#intern</strong> 方法：intern 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中返回这个新字符串的引用，若存在（使用 equals() 方法进行确定）那么就会返回 String Pool 中字符串的引用；</p><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><hr><h2 id="String-常用方法"><a href="#String-常用方法" class="headerlink" title="String 常用方法"></a>String 常用方法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">endsWith</span><span class="token punctuation">(</span>String suffix<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//测试此字符串是否以指定的后缀结束</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//返回指定索引处的 char 值</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">)</span><span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">split</span><span class="token punctuation">(</span>String regex<span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">)</span>   <span class="token keyword">public</span> String <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">char</span> oldChar<span class="token punctuation">,</span><span class="token keyword">char</span> newChar<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h1 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h1><p>在 Java 中 Object 是所有的祖类。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">native</span> Object <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException</code></pre><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><p><strong>“==”和equals的区别</strong></p><p><code>==</code>： 用来判断两个对象的内存地址是否相同（比较的是变量(栈)内存中存放的对象的(堆)内存地址，）。比较的是真正意义上的指针操作。</p><p><code>equals</code>：用来比较的是两个对象的内容是否相等</p><pre><code>String s1 = new String(&quot;ab&quot;); // s1 为一个引用String s2 = new String(&quot;ab&quot;); // s2 为另一个引用,对象的内容一样String s3 = &quot;ab&quot;; // 放在常量池中String s4 = &quot;ab&quot;; // 从常量池中查找System.out.println(s1 == s2); // falseSystem.out.println(s3 == s4); // trueSystem.out.println(s1 == s3); // falseSystem.out.println(s1.equals(s2)); // trueSystem.out.println(s3.equals(s4)); // trueSystem.out.println(s1.equals(s3)); // true</code></pre><p>对equals重新需要注意五点：</p><ul><li>1 自反性：对任意引用值X，x.equals(x)的返回值一定为true；</li><li>2 对称性：对于任何引用值x,y,当且仅当y.equals(x)返回值为true时，x.equals(y)的返回值一定为true；</li><li>3 传递性：如果x.equals(y)=true, y.equals(z)=true,则x.equals(z)=true ；</li><li>4 一致性：如果参与比较的对象没任何改变，则对象比较的结果也不应该有任何改变；</li><li>5 非空性：任何非空的引用值X，x.equals(null)的返回值一定为false 。</li></ul><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>所以：在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p><strong>为什么要有 hashCode？</strong>因为 <code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，确定该对象在哈希表中的索引位置</p><p><strong>hashCode（）与equals（）</strong></p><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h2 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h2><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><p>克隆（clone方法）为浅拷贝</p><p><strong>1.浅拷贝</strong>：对基本数据类型进行值拷贝，对引用数据类型的<code>引用地址进行拷贝</code>，拷贝对象和原始对象的引用类型引用同一个对象</p><p><strong>2.深拷贝</strong>： 对基本数据类型进行值拷贝，对引用数据类型的<code>内容进行拷贝</code>，拷贝对象和原始对象的引用类型引用不同对象。</p><p><strong>深拷贝实现</strong>：</p><ul><li><code>序列化</code>（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。</li><li><code>实现Clonable接口</code>，覆盖并重写clone()，除了调用父类中的clone方法得到新的对象， 还要将该类中的引用变量也clone出来。如果只是用<strong>Object中默认的clone方法，是浅拷贝的</strong></li></ul><pre><code>public class Test implements Cloneable {    private int[] arr = {1,2,3,4};    @Override    protected Test clone() throws CloneNotSupportedException {        Test newBody = (Test) super.clone();        newBody.arr = arr.clone();    // 深拷贝实现        return newBody;    }}</code></pre><p>开发中常用的对象拷贝工具：</p><p>例如DozerMapper、Apache BeanUtils、Spring、Jodd BeanUtils、甚至是Cglib 都提供了这样的功能</p><p>选择Cglib的 <strong>BeanCopier</strong> 进行Bean拷贝的理由是，其性能要比 <strong>Spring的BeanUtils **，</strong>Apache的BeanUtils <strong>和 **PropertyUtils</strong> 要好很多，尤其是数据量比较大的情况下</p><p>Cglib 的beans 包 操作</p><ul><li>BeanCopier：用于两个bean之间，同名属性间的拷贝。</li><li>BulkBean：用于两个bean之间，自定义get&amp;set方法间的拷贝。</li><li>BeanMap：针对POJO Bean与Map对象间的拷贝。</li><li>BeanGenerator：根据Map&lt;String,Class&gt;properties的属性定义，动态生成POJO Bean类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础篇（3）常用关键字特性</title>
      <link href="/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%883%EF%BC%89%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E7%89%B9%E6%80%A7/"/>
      <url>/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%883%EF%BC%89%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>本章中主要了解一下我们在开发过程中常用，也必须掌握的一些特殊关键字的作用。</p><h1 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h1><p>在Java中有4中访问权限的修饰符：<strong>private</strong>、<strong>default</strong>（(默认一般省略）、<strong>public</strong>、<strong>protected</strong>。一般用于对类或类中的成员（字段以及方法）加上访问修饰符</p><p>权限的主要作用范围：同一个类中、同一个包下、父子类、不同的包</p><p>可被修饰对象：类和成员变量；类可见表示其它类可以用这个类创建实例对象；成员可见表示其它类可以用这个类的实例对象访问到该成员。</p><p><strong>4种修饰符的权限范围：</strong></p><blockquote><ul><li>private：指”私有的”。被其修饰的属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问</li><li>default：即不加任何访问修饰符，通常称为“默认访问权限“或者“包访问权限”。该模式下，只允许在同一个包中进行访问。</li><li>protected: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护访问权限”。被其修饰的属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。</li><li>public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包访问。</li></ul></blockquote><table><thead><tr><th>修饰符</th><th>同类</th><th align="left">同包</th><th>子类</th><th>不同包非子类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td align="left">×</td><td>×</td><td>×</td></tr><tr><td>default</td><td>√</td><td align="left">√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td align="left">√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td align="left">√</td><td>√</td><td>√</td></tr></tbody></table><p>从上表中我们很容易看出，权限范围从小到大依次为：<strong>private &lt; default &lt; protected &lt; public</strong></p><hr><h1 id="final-和-static"><a href="#final-和-static" class="headerlink" title="final 和 static"></a>final 和 static</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>在Java中，final关键字可以用来修饰类、方法和变量（包括成员变量和局部变量）</p><ul><li><strong>修饰变量</strong>：表示常量，对于基本类型，final 使数值不变；对于引用类型，final 使引用地址不变，但对象本身的属性是可以被修改的。</li><li><strong>修饰方法</strong>：不能被子类的方法重写，但可以被继承，<strong>不能修饰构造方法</strong>。。</li><li><strong>修饰类</strong> ：该不能被继承，没有子类，final类中的方法默认是final的。Java中的String类就是一个final类</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>在Java语言中，static 可以用来修饰成员变量和成员方法，当然也可以是静态代码块</p><ul><li><strong>静态变量</strong>：又称为类变量，该类的所有实例都共享本类的静态变量，且在内存中只存在一份</li><li><strong>静态方法</strong>：在类加载的时候就存在了，它不依赖于任何实例，只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字（此时可能没有实例）。</li><li><strong>静态语句块</strong>：在类初始化时运行一次。</li><li><strong>静态内部类</strong>：非静态内部类依赖于外部类的实例，而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</li></ul><p><strong>使用时注意：</strong></p><ol><li>静态变量，静态方法可以通过类名直接访问</li><li>初始化顺序：静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。（此处不演示，在类初始化篇章中演示）</li></ol><p><strong>问：在一个静态方法内调用一个非静态成员为什么是非法的?</strong></p><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p><h2 id="成员变量、静态变量、局部变量的区别"><a href="#成员变量、静态变量、局部变量的区别" class="headerlink" title="成员变量、静态变量、局部变量的区别"></a><strong>成员变量、静态变量、局部变量的区别</strong></h2><p>从生命周期比较：</p><ul><li>静态变量可以被对象调用，也可以被类名调用。以static关键字申明的变量，其独立在对象之外，有许多对象共享的变量。在对象产生之前产生，存在于<strong>方法区静态区中</strong>。</li><li>成员变量只能被对象调用。随着对象创建而存在，随对象销毁而销毁。存在于<strong>堆栈内存中</strong></li><li>局部变量在方法或语句块中申明的变量，生命周期只在定义的{}之中，不能跨方法或语句块使用。</li></ul><p>从访问权限比较：</p><ul><li><strong>静态变量称为对象的共享数据</strong>，成员变量可以称为对象的特有数据，局部变量为方法所有</li><li>成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li></ul><hr><h1 id="abstract-和-interface"><a href="#abstract-和-interface" class="headerlink" title="abstract 和 interface"></a>abstract 和 interface</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>在 Java 中 abstract 即抽象，一般使用 <code>abstract</code> 关键字修饰的类或方法</p><p>修饰的类时</p><blockquote><ol><li>不能被实例化，需要继承抽象类才能实例化其子类。</li><li>访问权限可以使用<code>public</code>、<code>private</code>、<code>protected</code>，其表达形式为：（public）abstract class 类名{} </li><li>抽象类不能使用final关键字修饰，因为final修饰的类是无法被继承</li><li>可以定义构造方法、静态方法、普通方法；非抽象的普通成员变量、静态成员变量</li></ol></blockquote><p>修饰的方法时</p><blockquote><ol><li>含有该抽象方法的类必须定义为抽象类，但抽象类可以没有抽象方法。</li><li>访问权限可以使用<code>public</code>、<code>default</code>、<code>protected</code>，不能为<code>private</code>，因为抽象方法必须被子类实现（覆写），而private权限对于子类来 说是不能访问的，所以就会产生矛盾，</li><li>不能用static修饰，因为没有主体</li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span>  <span class="token keyword">class</span>  <span class="token class-name">MyAbstract</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String name<span class="token operator">=</span><span class="token string">"小米"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> price<span class="token operator">=</span> <span class="token number">1800</span><span class="token punctuation">;</span>    <span class="token function">MyAbstract</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//权限不能为 private</span><span class="token punctuation">}</span></code></pre><h2 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h2><p>在 Java中 interface 即接口，是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，Java 8 开始，接口也可以拥有<code>default</code>的方法实现，是因为不支持默认方法的接口的维护成本太高</p><blockquote><ol><li>接口的方法访问权限只能为 <code>public</code>，Java 8可以为<code>default</code>，但是必须有方法体</li><li>接口的方法默认<code>public abstract</code> 也可以由 static 修饰</li><li>接口的方法可以定义为 <code>public static</code> ，但是必须有方法体，且只能有接口类名调用</li><li>成员变量默认为<code>public staic final</code></li></ol></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span>  <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> price <span class="token operator">=</span> <span class="token number">1800</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">outName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyInterface print： default Method"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"MyInterface price="</span><span class="token operator">+</span>price<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterfaceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MyInterface</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">outName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I'm a MyInterfaceImpl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MyInterface my <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInterfaceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        my<span class="token punctuation">.</span><span class="token function">outName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        my<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        MyInterfaceImpl.print();// 实现类类名调用时， 提示编译错误</span>        MyInterface<span class="token punctuation">.</span><span class="token function">price</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="abstract-和-interface-的区别"><a href="#abstract-和-interface-的区别" class="headerlink" title="abstract 和 interface 的区别"></a>abstract 和 interface 的区别</h2><p><strong>从定义分析</strong></p><ul><li>抽象类和接口都不能直接实例化；抽象方法必须由子类来进行重写</li><li>抽象类单继承，接口多实现</li><li>抽象类可有构造方法，普通成员变量，非抽象的普通方法，静态方法</li><li>抽象类的抽象方法访问权限可以为：public、protected 、default</li><li>接口中变量类型默认public staic final，</li><li>接口中普通方法默认public abstract，没有具体实现</li><li>jdk1.8 中接口可有<strong>静态方法和default（有方法体）方法</strong></li></ul><p><strong>从应用场合分析</strong></p><ul><li>接口：需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。</li><li>抽象类：1、在既需要统一的接口，又需要实例变量或缺省的方法的情况下就可以使用它；2、定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础篇（2）三大特性和六大原则</title>
      <link href="/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%882%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
      <url>/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%882%EF%BC%89%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E5%92%8C%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h1><p>在 Java 编程中三大特性指的是<strong>封装、继承、多态</strong></p><ul><li>封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问优点：减少耦合，代码重用，减轻维护</li><li>继承：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</li><li>多态：指允许不同类的对象对同一消息做出响应。</li></ul><hr><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态一般分为编译时多态和运行时多态，编译时主要指方法的重载；运行时主要指程序中定义的对象引用所指向的具体类型在运行期间才确定</p><p><strong>运行时多态有三个条件：继承、覆盖和重写、向上转型（父类引用指向子类对象）</strong></p><hr><h2 id="方法重载和重写区别"><a href="#方法重载和重写区别" class="headerlink" title="方法重载和重写区别"></a>方法重载和重写区别</h2><p>重写：<strong>发生在继承类中，方法名和参数列表相同</strong>，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>重载：<strong>发生在同一个类中，方法名相同，参数列表不同（个数、类型、顺序），与权限修饰、返回值类型、抛出异常无关</strong></p><p><strong>注意</strong>：构造器是不可以被重写的，但是能重载。</p><p>构造方法有哪些特性？</p><ol><li>名字与类名相同。</li><li>没有返回值，但不能用void声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><hr><h1 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h1><ol><li><strong>开闭原则</strong>：对扩展开发放，对修改关闭，要求在添加新功能时不需要修改代码，符合开闭原则最典型的设计模式是装饰者模式</li><li><strong>单一职责原则</strong>：一个类只负责一件事，尽量使用合成/聚合的方式，而不是使用继承。</li><li><strong>里式替换原则</strong> ：任何基类可以出现的地方，子类一定可以出现。</li><li><strong>依赖倒转原则</strong>：依赖于抽象而不依赖于具体</li><li><strong>接口隔离原则</strong>：使用多个隔离的接口，比使用单个接口要好 ，不应该强迫客户依赖于它们不用的方法。</li><li><strong>迪米特法则</strong>：一个软件实体应当尽可能少地与其他实体发生相互作用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础篇（1）总纲</title>
      <link href="/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%881%EF%BC%89%E6%80%BB%E7%BA%B2/"/>
      <url>/2020/01/05/Java-%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%881%EF%BC%89%E6%80%BB%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<p>​        Java 篇章中，一般我们面试时都会考察我们掌握的基础点，看是否基础牢固，决定了我们是不是能进一步的交流，如果一个人的基础都牢固，那面试官肯定不要你。</p><p>以下我们从以下几个方便来巩固以下我们的技术点：</p><ul><li>三大特性和六大原则</li><li>关键字</li><li>数据类型</li><li>类初始化</li><li>逻辑运算</li><li>异常</li><li>反射</li></ul><p><img src="Java%E5%9F%BA%E7%A1%80.png" alt="Java基础"></p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
